import { spawn } from "child_process";
import { config as dotenvConfig } from "dotenv";
import prettier from "prettier";
import * as path from "path";
import * as fs from "fs";
import { ethers } from "ethers";
import * as viemChains from "viem/chains";
import { arbitrumNitro } from "../../nextjs/utils/scaffold-eth/chain";
import scaffoldConfig from "../../nextjs/scaffold.config";

// Load environment variables from .env file
const envPath = path.resolve(__dirname, "../.env");
if (fs.existsSync(envPath)) {
  dotenvConfig({ path: envPath });
}

export interface DeploymentConfig {
  endpoint: string;
  privateKey: string;
  contractName: string;
  deploymentDir: string;
  contractAddress?: string;
  network?: string;
}

export interface ExportConfig {
  contractName: string;
  deploymentDir: string;
  contractAddress: string | undefined;
}

export const generatedContractComment = `
/**
 * This file is autogenerated by scaffold-stylus.
 * You should not edit it manually or your changes might be overwritten.
 */
`;

export function getDeploymentConfig(): DeploymentConfig {
  const network = process.env["NETWORK"];
  let endpoint = process.env["RPC_URL"] || "http://localhost:8547";

  // If network is specified, try to get RPC URL from viem chains
  if (network) {
    const viemRpcUrl = getRpcUrlFromViemChain(network);
    if (viemRpcUrl) {
      endpoint = viemRpcUrl;
      console.log(
        `üåê Using RPC URL from viem for network '${network}': ${endpoint}`,
      );
    } else {
      console.warn(
        `‚ö†Ô∏è  Could not find RPC URL for network '${network}' in viem chains. Using config endpoint: ${endpoint}`,
      );
    }
  }

  return {
    endpoint,
    privateKey:
      process.env["PRIVATE_KEY"] ||
      "0xb6b15c8cb491557369f3c7d2c287b053eb229daa9c22138887752191c9520659",
    contractName: process.env["CONTRACT_NAME"] || "stylus-hello-world",
    deploymentDir: process.env["DEPLOYMENT_DIR"] || "./deployments",
    ...(network && { network }),
  };
}

export function getExportConfig(): ExportConfig {
  return {
    contractName: process.env["CONTRACT_NAME"] || "stylus-hello-world",
    deploymentDir: process.env["DEPLOYMENT_DIR"] || "./deployments",
    contractAddress: process.env["STYLUS_CONTRACT_ADDRESS"],
  };
}

export function ensureDeploymentDirectory(deploymentDir: string): void {
  const fullPath = path.resolve(__dirname, "..", deploymentDir);
  if (!fs.existsSync(fullPath)) {
    console.log(`üìÅ Creating deployment directory: ${fullPath}`);
    fs.mkdirSync(fullPath, { recursive: true });
  }
}

export function executeCommand(
  command: string,
  cwd: string,
  description: string,
): Promise<string> {
  console.log(`\nüîÑ ${description}...`);
  // Sanitize command to hide private key (create a copy to avoid modifying original)
  const sanitizedCommand = command.slice();
  console.log(
    `Executing: ${sanitizedCommand.replace(/--private-key=[^\s]+/g, "--private-key=***")}`,
  );

  return new Promise((resolve, reject) => {
    const childProcess = spawn(command, [], {
      cwd,
      shell: true,
      stdio: ["inherit", "pipe", "pipe"],
    });

    let output = "";
    let errorOutput = "";
    const outputLines: string[] = [];
    let errorLines: string[] = [];

    // Handle stdout
    if (childProcess.stdout) {
      childProcess.stdout.on("data", (data: Buffer) => {
        const chunk = data.toString();
        output += chunk;
        const newLines = chunk.split("\n");
        outputLines.push(...newLines);
      });
    }

    // Handle stderr
    if (childProcess.stderr) {
      childProcess.stderr.on("data", (data: Buffer) => {
        const chunk = data.toString();
        errorOutput += chunk;
        const newLines = chunk.split("\n");
        errorLines.push(...newLines);
        // Keep only the last 5 lines
        if (errorLines.length > 5) {
          errorLines = errorLines.slice(-5);
        }
      });
    }

    // Handle process completion
    childProcess.on("close", (code: number | null) => {
      if (code === 0) {
        console.log(`\n‚úÖ ${description} completed successfully!`);
        // Print output starting from "project metadata hash computed on deployment" or error patterns, or all logs if not found
        if (outputLines.length > 0) {
          const metadataIndex = outputLines.findIndex((line) =>
            line.includes("project metadata hash computed on deployment"),
          );
          const errorIndex = outputLines.findIndex((line) =>
            line.includes("error["),
          );

          let startIndex = -1;
          if (metadataIndex >= 0) {
            startIndex = metadataIndex;
          } else if (errorIndex >= 0) {
            startIndex = errorIndex;
          }

          if (startIndex >= 0) {
            const linesToPrint = outputLines.slice(startIndex);
            linesToPrint.forEach((line) => {
              if (line.trim()) console.log(line);
            });
          } else {
            outputLines.forEach((line) => {
              if (line.trim()) console.log(line);
            });
          }
        }
        resolve(output);
      } else {
        console.error(`\n‚ùå ${description} failed with exit code ${code}`);
        // Print error output starting from "project metadata hash computed on deployment" or error patterns, or all logs if not found
        if (errorLines.length > 0) {
          const metadataIndex = errorLines.findIndex((line) =>
            line.includes("project metadata hash computed on deployment"),
          );
          const errorIndex = errorLines.findIndex((line) =>
            line.includes("error["),
          );

          let startIndex = -1;
          if (metadataIndex >= 0) {
            startIndex = metadataIndex;
          } else if (errorIndex >= 0) {
            startIndex = errorIndex;
          }

          if (startIndex >= 0) {
            const linesToPrint = errorLines.slice(startIndex);
            linesToPrint.forEach((line) => {
              if (line.trim()) console.error(line);
            });
          } else {
            errorLines.forEach((line) => {
              if (line.trim()) console.error(line);
            });
          }
        }
        if (errorOutput) {
          console.error(errorOutput);
        }
        reject(
          new Error(
            `Command failed with exit code ${code}. Error output: ${errorOutput}`,
          ),
        );
      }
    });

    // Handle process errors
    childProcess.on("error", (error: Error) => {
      console.error(`\n‚ùå ${description} failed:`, error);
      reject(error);
    });
  });
}

export async function generateTsAbi(
  abiFilePath: string,
  contractName: string,
  contractAddress: string,
) {
  const TARGET_DIR = "../nextjs/contracts/";
  const abiTxt = fs.readFileSync(abiFilePath, "utf8");

  // Extract from 4th row to the end
  const lines = abiTxt.split("\n");
  const extractedAbi = lines.slice(3).join("\n");

  const fileContent = `${scaffoldConfig.targetNetworks[0]?.id || arbitrumNitro.id}:{"${contractName}":{address:"${contractAddress}",abi:${extractedAbi}}}`;

  if (!fs.existsSync(TARGET_DIR)) {
    fs.mkdirSync(TARGET_DIR);
  }

  fs.writeFileSync(
    `${TARGET_DIR}deployedContracts.ts`,
    await prettier.format(
      `${generatedContractComment} import { GenericContractsDeclaration } from "~~/utils/scaffold-eth/contract"; \n\n
 const deployedContracts = {${fileContent}} as const; \n\n export default deployedContracts satisfies GenericContractsDeclaration`,
      {
        parser: "typescript",
      },
    ),
  );

  console.log(
    `üìù Updated TypeScript contract definition file on ${TARGET_DIR}deployedContracts.ts`,
  );
}

export function handleSolcError(
  error: Error,
  context: string = "ABI export",
): void {
  console.error(`\n‚ùå ${context} failed!`);
  console.error("\nüîç Error details:", error.message);

  // Check if the error is related to solc not being found
  if (
    error.message.includes("solc") ||
    error.message.includes("solidity") ||
    error.message.includes("command not found")
  ) {
    console.error(
      "\nüí° It appears that the Solidity compiler (solc) is not installed on your system.",
    );
    console.error("\nüìö To install Solidity, please visit:");
    console.error(
      "   https://docs.soliditylang.org/en/latest/installing-solidity.html",
    );
    console.error(
      "\nüöÄ After installing solc, you can run this command again:",
    );
    console.error("   yarn export-abi");
    console.error("\nüìã Quick installation options:");
    console.error("   ‚Ä¢ npm: npm install --global solc");
    console.error("   ‚Ä¢ Docker: docker run ethereum/solc:stable --help");
    console.error("   ‚Ä¢ Homebrew (macOS): brew install solidity");
    console.error("   ‚Ä¢ Linux: sudo apt-get install solc");
  } else {
    console.error("\nüí° Please check the error details above and try again.");
  }
}

export function generateContractAddress(): string {
  // Generate a random private key and derive the address
  const wallet = ethers.Wallet.createRandom();
  return wallet.address;
}

export function extractDeployedAddress(output: string): string | null {
  // Look for the line containing "deployed code at address:"
  const lines = output.split("\n");
  for (const line of lines) {
    if (line.includes("deployed code at address:")) {
      // Simple approach: just extract the hex address directly
      const hexMatch = line.match(/(0x[a-fA-F0-9]{40})/);
      if (hexMatch && hexMatch[1]) {
        return hexMatch[1];
      }
    }
  }
  return null;
}

export function getRpcUrlFromViemChain(networkName: string): string | null {
  try {
    // Normalize network name and handle aliases
    const normalizedName = networkName.toLowerCase();

    // Map aliases to actual network names
    const networkAliases: Record<string, string> = {
      mainnet: "arbitrum",
      testnet: "arbitrumSepolia",
    };

    // Use alias if it exists, otherwise use the original name
    const actualNetworkName = networkAliases[normalizedName] || networkName;

    // Only support Arbitrum networks (case-insensitive)
    const supportedNetworks = ["arbitrum", "arbitrumSepolia"];
    const isSupported = supportedNetworks.some(
      (n) => n.toLowerCase() === actualNetworkName.toLowerCase(),
    );
    if (!isSupported) {
      console.warn(
        `‚ö†Ô∏è  Network '${networkName}' is not supported. Supported networks: ${supportedNetworks.join(", ")}`,
      );
      return null;
    }

    // Get all chain properties from viem
    const chainEntries = Object.entries(viemChains);

    // Find the chain by name (case-insensitive)
    const chainEntry = chainEntries.find(([key, chain]) => {
      const chainKey = key.toLowerCase();
      const chainName = chain.name.toLowerCase();
      return (
        chainKey === actualNetworkName.toLowerCase() ||
        chainName === actualNetworkName.toLowerCase()
      );
    });

    if (!chainEntry) {
      console.warn(
        `‚ö†Ô∏è  Could not find chain configuration for '${actualNetworkName}' in viem chains`,
      );
      return null;
    }

    const chain = chainEntry[1];

    // Get the first HTTP RPC URL from the default rpcUrls
    if (chain.rpcUrls?.default?.http && chain.rpcUrls.default.http.length > 0) {
      return chain.rpcUrls.default.http[0];
    }

    // Fallback to public RPC URLs if default is not available
    if (
      "public" in chain.rpcUrls &&
      chain.rpcUrls.public?.http &&
      chain.rpcUrls.public.http.length > 0
    ) {
      return chain.rpcUrls.public.http[0];
    }

    console.warn(`‚ö†Ô∏è  No RPC URLs found for chain '${actualNetworkName}'`);
    return null;
  } catch (error) {
    console.error(`Error getting RPC URL for network ${networkName}:`, error);
    return null;
  }
}
